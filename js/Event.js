// Generated by CoffeeScript 1.12.4
var Event, Listener, ListenerArray, Type, assertTypes, emptyFunction, frozen, isDev, type;

require("LazyVar");

frozen = require("Property").frozen;

emptyFunction = require("emptyFunction");

assertTypes = require("assertTypes");

isDev = require("isDev");

Type = require("Type");

ListenerArray = require("./ListenerArray");

Listener = require("./Listener");

type = Type("Event");

type.defineArgs({
  id: String.Maybe,
  types: Object.Maybe,
  async: Boolean.Maybe
});

type.defineFrozenValues(function(options) {
  return {
    id: options.id,
    _async: options.async
  };
});

type.defineValues(function(options) {
  if (options == null) {
    options = {};
  }
  return {
    types: options.types,
    _events: options._events,
    _listeners: !options._events ? null : void 0
  };
});

type.defineFunction(function(callback) {
  if (this._events) {
    return this._events.on(this.id, callback);
  } else {
    return this._attach(callback);
  }
});

type.defineMethods({
  bindEmit: function() {
    return this._boundEmit || this._bindEmit();
  },
  applyEmit: function(args) {
    return this.emit.apply(this, args);
  },
  emit: function(data) {
    if (isDev && this.types) {
      assertTypes(data, this.types);
    }
    if (this._events) {
      return this._events.applyEmit(this.id, arguments);
    }
    if (this._listeners) {
      return this._listeners.notify(arguments);
    }
  },
  once: function(callback) {
    if (this._events) {
      return this._events.once(this.id, callback);
    } else {
      return this._attach(function() {
        this.detach();
        return callback.apply(this, arguments);
      });
    }
  },
  _attach: function(callback) {
    var listener;
    if (!this._listeners) {
      this._listeners = ListenerArray({
        async: this._async,
        onAttach: this._onAttach.bind(this)
      });
    }
    listener = Listener(callback, this._onDetach);
    return this._listeners.attach(listener);
  },
  _onAttach: function(listener) {
    return Event.didAttach.emit(listener, this);
  },
  _onDetach: emptyFunction,
  _bindEmit: function() {
    frozen.define(this, "_boundEmit", {
      value: this.emit.bind(this)
    });
    return this._boundEmit;
  }
});

type.defineStatics({
  Listener: Listener,
  Map: {
    lazy: function() {
      return require("./EventMap");
    }
  },
  installMixin: function() {
    return require("./EventMixin");
  },
  getListeners: function(callback) {
    var listeners, onAttach;
    listeners = [];
    onAttach = this.didAttach.on(function(listener) {
      return listeners.push(listener);
    });
    callback();
    onAttach.detach();
    return listeners;
  },
  didAttach: {
    get: function() {
      var didAttach;
      frozen.define(this, "didAttach", {
        value: didAttach = Event()
      });
      frozen.define(didAttach, "_onAttach", {
        value: emptyFunction
      });
      return didAttach;
    }
  }
});

module.exports = Event = type.build();
