// Generated by CoffeeScript 1.12.4
var Listener, Type, assertType, emptyFunction, immediate, type;

emptyFunction = require("emptyFunction");

assertType = require("assertType");

immediate = require("immediate");

Type = require("Type");

Listener = require("./Listener");

type = Type("ListenerArray");

type.defineArgs(function() {
  return {
    types: {
      async: Boolean,
      onAttach: Function
    },
    defaults: {
      onAttach: emptyFunction
    }
  };
});

type.defineValues(function(options) {
  return {
    _value: null,
    _length: 0,
    _isNotifying: false,
    _onAttach: options.onAttach,
    _detached: [],
    _queue: options.async ? [] : void 0
  };
});

type.defineGetters({
  length: function() {
    return this._length;
  },
  isNotifying: function() {
    return this._isNotifying;
  }
});

type.defineMethods({
  attach: function(listener) {
    var oldValue;
    assertType(listener, Listener);
    listener._listeners = this;
    if (oldValue = this._value) {
      if (oldValue.constructor === Listener) {
        this._update([oldValue, listener], 2);
      } else {
        this._update(oldValue, oldValue.push(listener));
      }
    } else {
      this._update(listener, 1);
    }
    this._onAttach(listener);
  },
  notify: function(data) {
    if (!this._value) {
      return;
    }
    if (!this._queue) {
      this._isNotifying = true;
      this._notify(data);
      this._isNotifying = false;
      this._flush();
      return;
    }
    if (this._isNotifying || this._queue.length) {
      this._queue.push(data);
      return;
    }
    this._notifyAsync(data);
  },
  detach: function(listener) {
    var index, newCount, oldValue;
    assertType(listener, Listener);
    listener._listeners = null;
    if (this._isNotifying) {
      this._detached.push(listener);
      return;
    }
    if (!(oldValue = this._value)) {
      throw Error("No listeners are attached!");
    }
    if (oldValue.constructor === Listener) {
      if (listener !== oldValue) {
        throw Error("Listener is not attached to this ListenerArray!");
      }
      this._update(null, 0);
      return;
    }
    index = oldValue.indexOf(listener);
    if (index < 0) {
      throw Error("Listener is not attached to this ListenerArray!");
    }
    oldValue.splice(index, 1);
    newCount = oldValue.length;
    if (newCount === 1) {
      this._update(oldValue[0], 1);
    } else {
      this._update(oldValue, newCount);
    }
  },
  reset: function() {
    if (this._length) {
      this._update(null, 0);
    }
  },
  _update: function(newValue, newLength) {
    this._value = newValue;
    this._length = newLength;
  },
  _notify: function(data) {
    if (this._length === 1) {
      return this._value.notify(data);
    } else {
      return this._value.forEach(function(listener) {
        return listener.notify(data);
      });
    }
  },
  _notifyAsync: function(data) {
    this._isNotifying = true;
    immediate(this, function() {
      this._value && this._notify(data);
      this._isNotifying = false;
      this._flush();
      if (data = this._queue.shift()) {
        this._notifyAsync(data);
      }
    });
  },
  _flush: function() {
    var index, length, listeners;
    length = (listeners = this._detached).length;
    if (length === 0) {
      return;
    }
    if (length === 1) {
      this.detach(listeners.pop());
      return;
    }
    index = -1;
    while (++index < length) {
      this.detach(listeners[index]);
    }
    listeners.length = 0;
  }
});

module.exports = type.build();
